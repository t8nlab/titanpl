import fs from "fs";
import path from "path";
import esbuild from "esbuild";

export async function bundle() {
  const root = process.cwd();
  const actionsDir = path.join(root, "app", "actions");
  const outDir = path.join(root, "server", "actions");
  const rustOutDir = path.join(root, "server", "src", "actions_rust");

  const start = Date.now();
  await bundleJs(actionsDir, outDir);
  await bundleRust(rustOutDir, actionsDir);
  // console.log(`[Titan] Bundle finished in ${((Date.now() - start) / 1000).toFixed(2)}s`);
}

async function bundleJs(actionsDir, outDir) {
  // console.log("[Titan] Bundling JS actions...");

  fs.mkdirSync(outDir, { recursive: true });

  // Clean old bundles
  const oldFiles = fs.readdirSync(outDir);
  for (const file of oldFiles) {
    fs.unlinkSync(path.join(outDir, file));
  }

  const files = fs.readdirSync(actionsDir).filter(f => f.endsWith(".js") || f.endsWith(".ts"));
  if (files.length === 0) return;

  // console.log(`[Titan] Bundling ${files.length} JS actions...`);

  for (const file of files) {
    const actionName = path.basename(file, path.extname(file));

    const entry = path.join(actionsDir, file);

    // Rust runtime expects `.jsbundle` extension — consistent with previous design
    const outfile = path.join(outDir, actionName + ".jsbundle");

    // console.log(`[Titan] Bundling ${entry} → ${outfile}`);

    await esbuild.build({
      entryPoints: [entry],
      outfile,
      bundle: true,
      format: "iife",
      globalName: "__titan_exports",
      platform: "neutral",
      target: "es2020",
      logLevel: "silent",
      banner: {
        js: "const defineAction = (fn) => fn; const Titan = t;"
      },

      footer: {
        js: `
    (function () {
      const fn =
        __titan_exports["${actionName}"] ||
        __titan_exports.default;
    
      if (typeof fn !== "function") {
        throw new Error("[Titan] Action '${actionName}' not found or not a function");
      }
    
      globalThis["${actionName}"] = function(request_arg) {
         globalThis.req = request_arg;
         return fn(request_arg);
      };
    })();
    `
      }
    });
  }

  // console.log("[Titan] JS Bundling finished.");
}

export async function bundleRust(rustOutDir, actionsDir) {
  // console.log("[Titan] Bundling Rust actions...");

  // Fallback if called directly (though typically called via bundle)
  const root = process.cwd();
  if (!actionsDir) actionsDir = path.join(root, "app", "actions");
  if (!rustOutDir) rustOutDir = path.join(root, "server", "src", "actions_rust");


  if (!fs.existsSync(rustOutDir)) {
    fs.mkdirSync(rustOutDir, { recursive: true });
  }

  // Clean old rust actions
  for (const file of fs.readdirSync(rustOutDir)) {
    fs.unlinkSync(path.join(rustOutDir, file));
  }

  const files = fs.readdirSync(actionsDir).filter(f => f.endsWith(".rs"));
  if (files.length > 0) {
    // console.log(`[Titan] Bundling ${files.length} Rust actions...`);
  }

  const modules = [];

  for (const file of files) {
    const actionName = path.basename(file, ".rs");
    const entry = path.join(actionsDir, file);
    let outfile = path.join(rustOutDir, file);

    let content = fs.readFileSync(entry, 'utf-8');

    // Prepend implicit imports if not present
    let finalContent = content;
    if (!content.includes("use crate::extensions::t;")) {
      finalContent = "use crate::extensions::t;\n" + content;
    }

    // Basic validation - check if it has a run function
    if (!content.includes("async fn run")) {
      console.warn(`[Titan] Warning: ${file} does not appear to have an 'async fn run'. It might fail to compile.`);
    }

    fs.writeFileSync(outfile, finalContent);
    modules.push(actionName);
    // console.log(`[Titan] Copied Rust action ${actionName}`);
  }

  // Generate mod.rs
  let modContent = `// Auto-generated by Titan. Do not edit.
use axum::response::IntoResponse;
use axum::http::Request;
use axum::body::Body;
use std::future::Future;
use std::pin::Pin;

`;

  // Add mod declarations
  for (const mod of modules) {
    modContent += `pub mod ${mod};\n`;
  }

  modContent += `
pub type ActionFn = fn(Request<Body>) -> Pin<Box<dyn Future<Output = axum::response::Response> + Send>>;

pub fn get_action(name: &str) -> Option<ActionFn> {
    match name {
`;

  for (const mod of modules) {
    modContent += `        "${mod}" => Some(|req| Box::pin(async move { 
            ${mod}::run(req).await.into_response() 
        })),\n`;
  }

  modContent += `        _ => None
    }
}
`;

  fs.writeFileSync(path.join(rustOutDir, "mod.rs"), modContent);
  // console.log("[Titan] Rust Bundling finished.");
}
